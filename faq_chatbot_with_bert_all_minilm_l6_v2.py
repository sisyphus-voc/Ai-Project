# -*- coding: utf-8 -*-
"""FAQ chatbot with BERT-all-MiniLM-L6-v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xkRHnfPqO-yqXHPkXk10eyrXJnZBBnFo
"""

import pandas as pd

# Load dataset from CSV
df = pd.read_csv("faq_dataset.csv")

# Convert to list of dictionaries
faq_dataset = df.to_dict(orient="records")

print(faq_dataset[:5])  # Print the first 5 entries

!pip install transformers sentence-transformers

from sentence_transformers import SentenceTransformer
import numpy as np

# Load pre-trained model
model = SentenceTransformer('all-MiniLM-L6-v2')

# Extract all questions
faq_questions = [item["Question"] for item in faq_dataset]

# Generate embeddings for all FAQ questions
faq_embeddings = model.encode(faq_questions)

# User query
user_query = "Can you develop apps for mobile phones?"

# Generate embedding for the query
query_embedding = model.encode(user_query)

from sklearn.metrics.pairwise import cosine_similarity

# Compute cosine similarity between query and FAQ embeddings
similarities = cosine_similarity([query_embedding], faq_embeddings)

# Find the index of the most similar question
most_similar_idx = np.argmax(similarities)

# Retrieve the corresponding answer
best_match = faq_dataset[most_similar_idx]
print("Answer:", best_match["Answer"])

# Function to process user queries
def get_answer(user_query):
    # Generate embedding for the user's query
    query_embedding = model.encode(user_query)

    # Compute cosine similarity between query and FAQ embeddings
    similarities = cosine_similarity([query_embedding], faq_embeddings)

    # Find the index of the most similar question
    most_similar_idx = np.argmax(similarities)
    similarity_score = similarities[0][most_similar_idx]

    # Set a threshold for valid similarity
    threshold = 0.6  # Adjust this based on testing
    if similarity_score < threshold:
        return None, "I'm sorry, I couldn't find an answer to your question."

    # Retrieve the best match and its answer
    best_match = faq_dataset[most_similar_idx]
    return best_match["Question"], best_match["Answer"]

# Interactive loop
print("Welcome to the FAQ Chatbot! Type your question or 'exit' to quit.")
while True:
    user_query = input("You: ")  # Take user input
    if user_query.lower() == "exit":  # Exit condition
        print("Goodbye!")
        break

    # Get the best matching FAQ and answer
    question, answer = get_answer(user_query)
    print(f"Chatbot: {answer}")

# # Precompute embeddings for all questions in the dataset
# faq_questions = [faq["question"] for faq in faq_dataset]
# faq_embeddings = model.encode(faq_questions)

# Unified function to get answers with optional category filtering
def get_answer(user_query, user_category=None):
    # Filter FAQs by category (if specified)
    if user_category:
        filtered_dataset = [faq for faq in faq_dataset if faq["Category"].lower() == user_category.lower()]
    else:
        filtered_dataset = faq_dataset

    # Handle empty filtered datasets
    if not filtered_dataset:
        return None, "I'm sorry, no questions match your selected category."

    # Extract questions and compute embeddings for filtered dataset
    filtered_questions = [faq["Question"] for faq in filtered_dataset]
    filtered_embeddings = model.encode(filtered_questions)

    # Generate embedding for user query
    query_embedding = model.encode(user_query)

    # Compute cosine similarity
    similarities = cosine_similarity([query_embedding], filtered_embeddings)
    most_similar_idx = np.argmax(similarities)
    similarity_score = similarities[0][most_similar_idx]

    # Threshold for similarity
    threshold = 0.6
    if similarity_score < threshold:
        return None, "I'm sorry, I couldn't find an answer to your question."

    # Retrieve the best match
    best_match = filtered_dataset[most_similar_idx]
    return best_match["Question"], best_match["Answer"]

# Interactive chatbot loop
print("Welcome to the FAQ Chatbot! Type your question or 'exit' to quit.")
while True:
    # Ask the user for a query
    user_query = input("You: ")
    if user_query.lower() == "exit":
        print("Goodbye!")
        break

    # Ask if the user wants to specify a category
    category = input("Do you want to specify a category (e.g., 'Services', 'Pricing')? Type 'no' to skip: ")
    if category.lower() == "no":
        category = None

    # Get the answer based on the query and optional category
    question, answer = get_answer(user_query, user_category=category)
    print(f"Chatbot: {answer}")

